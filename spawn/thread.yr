mod thread;

extern (C) pthread_join (th : ulong, a : p!(p!(void)));
extern (C) pthread_exit (a : int);

public extern (C) sleep (a : int) -> void;

struct
| id : ulong
 -> Thread;

def print (const a : fn (int, char) -> void) {
    extern (C) printf (const c : p!char, ...);
    printf ("%d\n".ptr, a);
}

def spawn (T...) (n : uint, foo : fn (T)-> void, data : T) -> mut [Thread] {
    extern (C) pthread_create (thread : p!ulong, attr : p!void, ...) -> int;
    let res = [Thread ; n];
    
    for it in 0U .. n {
        let id = cast!ulong (it + 1U);
        let ptr = (ptr : p!(t!(fn (T) -> void, T))) {
            let (fun, data...) =  *ptr;
            fun (data.expand);
            return cast!(p!void) (null);
        };

        let alloc = [t!(fn (T) -> void, T) ; 1U];
        alloc[0] = (foo, data.expand);
        
        pthread_create (&id, null, ptr, alloc.ptr);        
        res [it] = Thread {id};
    }
    return res;
}



def join (const th : Thread) {
    pthread_join (th.id, null);
}

def join (const th : [Thread]) {
    for it in th
        pthread_join (it.id, null);
}

