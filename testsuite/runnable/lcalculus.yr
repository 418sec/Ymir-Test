import core.io;

struct -> True;
struct -> False;

def boolOr (T of True) () return true;
def boolOr (T of False) () return false;

struct (V, E)
| v : V
| e : E
 -> Lam;

def str (V, E) (lam : Lam!(V, E)) {
    return "Î» (" ~ lam.v.str () ~ "." ~ lam.e.str () ~ ")";
}

def str (T of (E1, E2), E1, E2) (a : T) {
    return "(" ~ a.0.str () ~ ")(" ~ a.1.str () ~ ")";
}

def str (x : X) return "x";
def str (y : Y) return "y";
def str (f : F) return "f";
def str (n : N) return "n";
def str (m : M) return "m";
def str (g : G) return "g";

def isVar (V) ()
    return is (V : X) || is (V : Y) || is (V : F) || is (V : G) || is (V : N) || is (V : M);

def canReduce (V) () return isVar!V != true;

def canReduce (V, E) () return canReduce!E ();
def canReduce (T of (E1, E2), E1, E2) () return (canReduce!E1 () || canReduce!E2 ());

def AppCanReduce (true, T of (E1, E2), E1, E2) () return true;
def AppCanReduce (false, T of (E1, E2), E1, E2) () return false;


def reduceTo (V, E) (lam : Lam!(V, E)) {
    let e = lam.e.reduceTo ();
    return Lam!(V, typeof (e)) {lam.v, lam.e};
}

def reduceTo (T of (E1, E2), E1, E2) (a : T) {
    return reduceTo!(canReduce!E1 (), canReduce!E2 ()) (a);
}

def reduceTo (true, false, T) (a : T) {
    return (a.0.reduceTo (), a.1); 
}

def reduceTo (false, false, T) (a : T) {
    return a;
}

def reduceTo (false, true, T) (a : T) {
    return (a.0, a.1.reduceTo ());
}
def reduceTo (true, true, T) (a : T) {
    return (a.0.reduceTo (), a.1.reduceTo ());
}

def CPlus () {
    return Lam!(M, Lam!(N, Lam!(F,  (M, (N, F)))))::init;
}

struct -> X;
struct -> Y;
struct -> F;
struct -> G;
struct -> M;
struct -> N;

def main () {
    let C0 = Lam!(F, Lam!(X, X))::init;
    let C1 = Lam!(F, Lam!(X, (F, X)))::init;
    let C2 = Lam!(F, Lam!(X, (F, (F,X))))::init;    
    let C3 = Lam!(F, Lam!(X, (F, (F, (F,X)))))::init;

    
    //let L0 = ((CPlus (), C2), C3);
    //    let L1 = L0.reduceTo ();
    
    println (C0.str ());
    
}
