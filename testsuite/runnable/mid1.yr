import core.io, core.string;

def testmatch () {
    let i;
    i = 3;
    match i {
        3 => {}
        0 | 1 | _ => assert (false);
    }
}

def testbreak () {
    let li = 0, lj = 0;
    for:Louter (i in 0 .. 10) {
        for j in 0 .. 10 {
            if j == 3
                break Louter;
            lj ++;
        }
        li ++;
    }

    assert (li == 0);
    assert (lj == 3);    
}

def foo (const s : [char]) {
    return match s {
        "hello" => 1;
        "goodbye" => 2;
        "goodb" => 3;
        _ => 10;
    };    
}

def teststringmatch () {
    let i = foo ("hello");
    assert (i == 1);
    
    i = foo ("goodbye");
    assert (i == 2);
    
    i = foo ("goodb");
    assert (i == 3);

    i = foo ("huzzah");
    assert (i == 10);
}

def testAccess () {
    let a = [u64 ; 10U];
    for i in 0U .. a.len {
        a [i] = i;
    }

    for i in 0U .. a.len {
        assert (a [i] == i);
    }

    let starray = [i32 ; 3U];
    cte assert (!__pragma (compiles, (starray [4] = 1)));
}

struct -> Test;

mod Foo {
    struct -> Inner;
}

def testArrayAlloc () {
    let a = [u64 ; 10U];
    let b = [string ; new 5U];
    let c = [Test ; new 3U];
    let d = [Foo::Inner ; new 2U];
    let e = [fn () -> void ; new 7U];
    let f = [dg (i32, Foo::Inner)-> Test ; new 4U];
}

def testAssert () {
    cte assert (true, "Error ??!!");
    cte assert (1 == 1, "Noooo ...");
    assert (true);
}

def testBinary () {
    let a = 1 + 2;
    cte assert (!__pragma (compiles, (1 + 1 = 4)));
    cte assert (__pragma (compiles, (a = a = 4)));    
}

def testBlock () {
    let cte inner = false;
    let innerRun = false;
    assert (!innerRun);
    let a = {
        inner = true;
        innerRun = true;
        12;
    };
    
    cte assert (inner);
    assert (innerRun);
}

def testBreak () {
    let i = 0;
    while true {
        i ++;
        break;        
    }
    assert (i == 1);
}

def testCast () {
    let a = 12;
    let b = cast!u64 (a);

    let c = "salut";
    let d = cast!([mut char]) (c);
    cte assert (!__pragma (compiles, (d [0] = 't')));    
}

def testLiteral () {
    let a = 1UB, b = 2B, c = 3US, d = 4S, e = 5U, f = 5, g = 6UL, h = 6L;
    cte assert (is (a : u8) && is (b : i8));
    cte assert (is (c : u16) && is (d : i16));
    cte assert (is (e : u32) && is (f : i32));
    cte assert (is (g : u64) && is (h : i64));

    let a_ = 10_000;
    let b_ = 0xFFFF;

    let f1 = .3f, f2 = 0.f, f3 = 0., f4 = .3;
    cte assert (is (f1 : f32) && is (f2 : f32) && is (f3 : f64) && is (f4 : f64));
    
    let c1 = 't', c2 = '\n', c3 = '\t';        
    cte assert (is (c2 : char) && is (c1 : char) && is (c3 : char));

    let s1 = "salut\n";
    cte assert (is (s1 : string));
    cte assert (!__pragma (compiles, (a [0] = 't')));

    let t1 = (a, b, c);
    cte assert (is (t1 : tuple) && is (t1 : (u8, i8, u16)));    

    let a1 = [1, 2, 3], a2 = [.4f, .3, .2];
    cte assert (is (a1 : [i32 ; 3U]) && is (a2 : [f64 ; 3U]));
}

mod DC1 {
    mod DC2 {
        struct -> Test;
        private def foo () {}
        def foo2() { foo (); }
    }
}

def equals (left : string, right : string) () {
    cte if left.len != right.len
        return false;
    else return left [0] == right [0] && equals!(left, right, 1);
}

def equals (left : string, right : string, i : i32) () {
    cte if i < left.len
        return left [i] == right [i] && equals!(left, right, i + 1);
    else return true;
}

def testDColon () {
    let a = DC1::DC2::Test {};
    let b = [DC1::DC2::Test {}];
    let c = [DC1::DC2::Test ; 10U];
    cte assert (__pragma (compiles, DC1::DC2::foo2 ()));
    cte assert (!__pragma (compiles, DC1::DC2::foo ()));
    
    assert (equals!(DC1::DC2::Test::typeid, "mid1.DC1.DC2.Test"));
}

def add10 (a : i32) -> i32 {
    return a + 10;
}

def add (a : i32, b : i32) -> i32 {
    return a + b;
}

struct
| a : i32
 -> TestDot;

def testDot () {
    let a = TestDot {10};
    let b = a.a;
    assert (10 == b);
    assert (b.add10 () == 20);
    assert (b.add (b) == 20);
}

def expandFoo (a : i32, b : i32) return a * b;
def expandFoo2 (a, b) return a + b;

def testExpand () {
    assert (expandFoo ((1, 2)::expand) == 2);
    assert (expandFoo2 ((1, 3.)::expand) == 4.);
}

def main () {
    testmatch ();
    testbreak ();
    teststringmatch ();
    testAccess ();
    testArrayAlloc ();    
    testAssert ();
    testBinary ();
    testBlock ();
    testBreak ();
    testCast ();
    testLiteral ();
    testDColon ();
    testDot ();
    testExpand ();
}
