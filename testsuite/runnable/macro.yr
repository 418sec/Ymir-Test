import core.io;
import core.string;
import std.math;

static current = 0;

def log (x) {
    for it in 0 .. current
        print (" ");
    println (x);
}

__macro json {
    
    ($z: expr ":" "{" *x: ($y: token) "}") {
        log (z);
        current += 4;
        json: { $(x) };
        current -= 4;
    }

    ($z: expr ":" "[" *x: ($y: expr, ",") "]") {
        log (z);
        current += 4;
        imut for it in x {
            log (it.y);
        }
        current -= 4;
    }

    
    ($x: expr) {
        log (x);
    }

    () {}

    ("{" *elem: ($y: token) "}") {
        json: { $(elem) };
    }
    
    (*x: (*elem: ($y: token), ",")) {
        imut for it in x {
            json: { $(it.elem) };
        }
    }
    
}

def test () {
   json: {
        "salut": {
            "test" : {},
            "array" : [1, 2, 3]
        },        
        "test": {}    
    };
}


__macro stringify {
    (*elem: ($i: token)) {
        let res = [char ; 0U];
        imut for it in elem
            res = res ~ it.i;
        res;
    }
}

def test2 () {
    let a = stringify: {salut comment ça va ?};
    assert (a == "salut comment ça va ?");
}

__macro comp {
    ($x: expr "|" $y: ident "in" $z: expr) {
        let res;
        {
            imut if (!is (z : [int])) {
                let y = z.fst;
                res = [ typeof (x); 0U ];
            } else {
                let y = z [0];
                res = [ typeof (x) ; 0U ];
            }
        }
        
        for y in z {
            res = res ~ [x];
        }
        res;
    }

    ($x: expr "|" $y: ident "in" $z: expr "if" $test: expr) {
        let res;
        {
            imut if (!is (z : [int])) {
                let y = z.fst;
                res = [ typeof (x); 0U ];
            } else {
                let y = z [0];
                res = [ typeof (x) ; 0U ];
            }
        }
        
        for y in z {
            if (test) 
                res = res ~ [x];
        }
        res;
    }   
}

def test3 () {
    let x = comp: [i | i in 0 .. 10];
    assert (x == [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]);

    let S = comp: [x.pow (2U) | x in 0 .. 10];
    let V = comp: [(2).pow (i) | i in 0U .. 13U];
    let M = comp: [x | x in S if x % 2 == 0];
}


def main () {
    test ();
    test2 ();
    test3 ();
    println ("success !!");
}
