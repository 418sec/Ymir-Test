mod src.game;

import core.io;
import core.string;
import std.memory;
import src.lib.signal;
import src.lib.sdl;
import src.screen;
import src.eventHandler;
import src.player;

struct
| screen : Screen
| eventHdl : EventHandler
| continue : bool
| mainPlayer : Player
 -> Game;

// for now...
imut WindowWidth = 600;
imut WindowHeight = 300;
imut WindowPosX = 100;
imut WindowPosY = 100;
imut Title = "Teelol";
imut PlayerName = "Abitbol";

def createGame (ref game : Game) 
{
    game.screen = createScreen (Title, WindowWidth, WindowHeight, WindowPosX, WindowPosY);
    game.eventHdl = createEventHandler (game);
    game.continue = true;
    game.mainPlayer = createPlayer (PlayerName.dup());

    game.screen.addDrawable (&(game.mainPlayer.drawable));
    
    initEvents (game.eventHdl);
}

def start (ref game : Game)
{
    let screen = game.screen;
    // we don't forget to free sdl at the end of the scope !
    on exit => screen.destroy();
    
    while (game.continue)
    {
        screen.clear();
        game.eventHdl.handleEvents ();
        screen.display();
    }
}

def initEvents (ref eventHdl : EventHandler)
{
    let quitSignal = Signal!(ref Game)::init;
    quitSignal.connect (onQuit);
    let keyUpSignal = Signal!(ref Game)::init;
    keyUpSignal.connect (onKeyUp);
    let keyDownSignal = Signal!(ref Game)::init;
    keyDownSignal.connect (onKeyDown);
    let keyRightSignal = Signal!(ref Game)::init;
    keyRightSignal.connect (onKeyRight);
    let keyLeftSignal = Signal!(ref Game)::init;
    keyLeftSignal.connect (onKeyLeft);
    let mouseLeftClickSignal = Signal!(ref Game, t!(int, int))::init;
    mouseLeftClickSignal.connect (onMouseLeftClick);
    let mouseRightClickSignal = Signal!(ref Game, t!(int, int))::init;
    mouseRightClickSignal.connect (onMouseRightClick);
    
    eventHdl.onEvent (SDL_EventType::QUIT, quitSignal);
    eventHdl.onEvent (SDL_EventType::KEYUP, SDL_Keycode::SDLK_ESCAPE, quitSignal);
    eventHdl.onEvent (SDL_EventType::KEYDOWN, SDL_Scancode::SDL_SCANCODE_UP, keyUpSignal);
    eventHdl.onEvent (SDL_EventType::KEYDOWN, SDL_Scancode::SDL_SCANCODE_DOWN, keyDownSignal);
    eventHdl.onEvent (SDL_EventType::KEYDOWN, SDL_Scancode::SDL_SCANCODE_RIGHT, keyRightSignal);
    eventHdl.onEvent (SDL_EventType::KEYDOWN, SDL_Scancode::SDL_SCANCODE_LEFT, keyLeftSignal);
    eventHdl.onEvent (SDL_EventType::MOUSEBUTTONUP, SDL_Mousecode::SDL_BUTTON_LEFT, mouseLeftClickSignal);
    eventHdl.onEvent (SDL_EventType::MOUSEBUTTONDOWN, SDL_Mousecode::SDL_BUTTON_RIGHT, mouseRightClickSignal);
}

def onQuit (ref game : Game)
{
    game.continue = false;
    println ("Bye !");
}

def onKeyUp (ref game : Game)
{
    game.mainPlayer.drawable.pos.y -= 10;
}

def onKeyDown (ref game : Game)
{
    game.mainPlayer.drawable.pos.y += 10;
}

def onKeyRight (ref game : Game)
{
    game.mainPlayer.drawable.pos.x += 10;
    println ("posX : ", game.mainPlayer.drawable.pos.x, ", posY : ", game.mainPlayer.drawable.pos.y);
        let ptr = &game;
    extern (C) printf (const c : p!char, ...);
    printf ("%p\n".ptr, cast!(p!Game) (ptr));
}

def onKeyLeft (ref game : Game)
{
    game.mainPlayer.drawable.pos.x -= 10;
}

def onMouseLeftClick (ref game : Game, pos : t!(int, int))
{
    let ptr = &game;
    extern (C) printf (const c : p!char, ...);
    printf ("%p\n".ptr, cast!(p!Game) (ptr));    
    // Putain mais pourquoi Ã§a marche pas
    // let res = game.mainPlayer.getResource();
    // let colorPtr = &((*res).color);
    // if ((*colorPtr) == ResourceColor::White)
    //     (*colorPtr) = ResourceColor::Red;
    // else
    //     (*colorPtr) = ResourceColor::White;
//     let (x, y) = pos;
//     println ("mposX : ", game.mainPlayer.drawable.pos.x, ", mposY : ", game.mainPlayer.drawable.pos.y); 
//     game.mainPlayer.drawable.pos.x += x;
//     game.mainPlayer.drawable.pos.y += y;
//     println ("x = ", x, ", y = ", y);
//     println ("mposX : ", game.mainPlayer.drawable.pos.x, ", mposY : ", game.mainPlayer.drawable.pos.y);
}

def onMouseRightClick (ref game : Game, pos : t!(int, int))
{
    println ("right click");
}
