mod src.game;

import core.io;
import core.string;

import std.memory;

import src.lib.signal;
import src.lib.sdl;
import src.screen;
import src.eventHandler;
import src.resource;

import src.player;
import src.collision;
import src.map;

struct
| screen : Screen
| eventHdl : EventHandler
| continue : bool
| mainPlayer : Player
| testPlayer : Player
 -> Game;

// for now...
// cte gWindowWidth = 640;
// cte gWindowHeight = 480;
cte gWindowPosX = 2024;
cte gWindowPosY = 100;
cte gTitle = "Teelol";
cte gPlayerName = "Abitbol";
cte gDefaultPosX = 200;
cte gDefaultPosY = 400;
cte gDefaultMapPath = "map/default.mp";

def createGame (ref game : Game)
{
    createGame (game, gDefaultMapPath);
}

def createGame (ref game : Game, mapFilePath : string) 
{
    let map = createMap (mapFilePath);
    map.loadInfo ();
    // we can't call loadMapContent() yet because it needs the ResourcesManager to be initialized and this one needs the screen to be created !
    
    game.screen = createScreen (gTitle, cast!i32 (map.width), cast!i32 (map.height), gWindowPosX, gWindowPosY);
    game.eventHdl = createEventHandler (game);
    game.continue = true;

    createResourcesManager (game.screen);
    createCollisionManager (cast!i32 (map.width), cast!i32 (map.height));
    
    game.mainPlayer = createPlayer (gPlayerName.dup(), gDefaultPosX, gDefaultPosY, ResourceType::Tee);
    game.testPlayer = createPlayer (gPlayerName.dup(), 50, 50, ResourceType::OtherTee);

    map.loadContent ();
    game.screen.addDrawables (map.getDrawables ());
    game.screen.addDrawables (game.mainPlayer.getDrawables ());
    game.screen.addDrawables (game.testPlayer.getDrawables ());

    let colManager = getCollisionManager ();
    colManager.addObject (&(game.mainPlayer.body));
    colManager.addObject (&(game.testPlayer.body));
    colManager.addObjects (map.getDrawables ());
    
    initEvents (game.eventHdl);

    on exit => map.close ();
}

def start (ref game : Game)
{
    let screen = game.screen;
    // we don't forget to free sdl at the end of the scope !
    on exit => screen.destroy();
    
    while (game.continue)
    {
        screen.clear();
        
        game.eventHdl.handleEvents ();
        game.passRow ();
        
        screen.display();
        SDL_Delay (8u);
    }
}

def passRow (ref game : Game)
{
    game.mainPlayer.passRow ();
    game.testPlayer.passRow ();
}

def initEvents (ref eventHdl : EventHandler)
{
    let quitSignal = Signal!(ref Game)::init;
    quitSignal.connect (onQuit);
        
    let keyRightSignal = Signal!(ref Game)::init;
    keyRightSignal.connect (onKeyRight);

    let keyLeftSignal = Signal!(ref Game)::init;
    keyLeftSignal.connect (onKeyLeft);

    let keySpaceSignal = Signal!(ref Game)::init;
    keySpaceSignal.connect (onKeySpace);
    
    eventHdl.onEvent (SDL_EventType::QUIT, quitSignal);
    eventHdl.onEvent (SDL_EventType::KEYUP, SDL_Keycode::SDLK_ESCAPE, quitSignal);

    eventHdl.onEvent (SDL_EventType::KEYDOWN, SDL_Scancode::SDL_SCANCODE_RIGHT, keyRightSignal);
    eventHdl.onEvent (SDL_EventType::KEYDOWN, SDL_Scancode::SDL_SCANCODE_LEFT, keyLeftSignal);

    eventHdl.onEvent (SDL_EventType::KEYDOWN, SDL_Keycode::SDLK_SPACE, keySpaceSignal);
}

def onQuit (ref game : Game)
{
    game.continue = false;
    println ("Bye !");
}

def onKeyRight (ref game : Game)
{
    game.mainPlayer.goRight ();
}

def onKeyLeft (ref game : Game)
{
    game.mainPlayer.goLeft ();
}

def onKeySpace (ref game : Game)
{
    game.mainPlayer.jump ();
}
