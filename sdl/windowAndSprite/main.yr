mod main;

import core.io;
import src.sdl;
import std.list;

extern (C) printf (const c : p!char, ...);

cte WindowWidth = 640;
cte WindowHeight = 480;
cte WindowPosX = 2200;
cte WindowPosY = 100;

struct
| posX : i32
| posY : i32
| offsetX : i32
| offsetY : i32
| width : i32
| height : i32
 -> Sprite;

def main() -> i32
{
    if (SDL_Init (SDLInitFlag::Video) != 0)
    {
        printf ("SDL_Init() error : %s\n".ptr, SDL_GetError());
        return -1;
    }

    let window = SDL_CreateWindow ("Test SDL with Ymir !".ptr, WindowPosX, WindowPosY, WindowWidth, WindowHeight, SDLWindowFlag::Shown);

    if (window is null)
    {
        printf ("SDL_CreateWindow() error : %s\n".ptr, SDL_GetError());
        return -1;
    }

    let renderer = SDL_CreateRenderer (window, -1, SDLRendererFlag::Accelerated);

    if (renderer is null)
    {
        printf ("SDL_CreateRenderer() error : %s\n".ptr, SDL_GetError());
        return -1;
    }

    SDL_RenderSetLogicalSize (renderer, WindowWidth, WindowHeight);

    let spriteSurface = IMG_Load ("sprites/goku.png".ptr);

    if (spriteSurface is null)
    {
        printf ("IMG_Load() error\n".ptr);
        return -1;
    }

    let spriteTexture = SDL_CreateTextureFromSurface (renderer, spriteSurface);
    SDL_FreeSurface (spriteSurface); // SDL_CreateTextureFromSurface copie les données, on peut libérer la surface

    let format = u32::init;
    let access = i32::init, w = i32::init, h = i32::init;

    if (SDL_QueryTexture (spriteTexture, &format, &access, &w, &h) < 0)
    {
        printf ("SDL_QueryTexture() error : %s\n".ptr, SDL_GetError());
        return -1;
    }

    let sprites = [Sprite ; 4u];
    sprites[0] = Sprite { 50, 50, 10, 450, 50, 100 };
    sprites[1] = Sprite { 50, 50, 70, 450, 50, 100 };
    sprites[2] = Sprite { 50, 50, 130, 450, 50, 100 };
    sprites[3] = Sprite { 50, 50, 185, 450, 50, 100 };

    SDL_SetRenderDrawBlendMode(renderer, SDLBlendMode::SDL_BLENDMODE_BLEND);
    SDL_SetRenderDrawColor(renderer, 0ub, 0ub, 255ub, 255ub);
    
    let stop = false;
    let event = SDLEvent::init;
    let index = 0u;
    
    while (!stop)
    {
        let spriteRect = SDLRect { sprites[index].posX, sprites[index].posY, sprites[index].width, sprites[index].height };
        let spriteLocation = SDLRect { sprites[index].offsetX, sprites[index].offsetY, sprites[index].width, sprites[index].height };
        if (SDL_RenderCopy (renderer, spriteTexture, &spriteLocation, &spriteRect) < 0)
        {
            printf ("SDL_RenderCopy() error : %s\n".ptr, SDL_GetError());
            return -1;
        }

        index = (index + 1u) % 4u;

        
        while (SDL_PollEvent (&event) != 0)
        {
            match event.type {
                SDLEventType::Quit => stop = true;
                SDLEventType::KeyUp => {
                    let keyEvent = cast!(p!SDLKeyboardEvent) (&event);
                    if ((*keyEvent).sym == SDL_Keycode::SDLK_ESCAPE)
                        stop = true;
                }
            }
        }
        
        SDL_RenderPresent (renderer);
        SDL_Delay (50u);
    }

    SDL_DestroyTexture (spriteTexture);
    SDL_DestroyRenderer (renderer);
    SDL_DestroyWindow (window);

    return 0;
}
