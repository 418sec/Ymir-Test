mod message;

import protocol;

mod Message {
    struct (T...)
    | id : u64
    | slots : [dg (T)-> void]
    | proto : p!Protocol
     -> Msg;
    
    def send (T...) (msg : Msg!T, datas : T) {
        let sock = msg.proto.stream;
        //let id = RawMsg!u64 {msg.id};
        //sock.write (id.data);
        cte for i in datas {
            sock.write (cast!(p!void) (&i), i::sizeof);
        }
    }

    def recv (T...) (msg : Msg!T) {
        let res = t!(T)::init;
        let sock = msg.proto.stream;
        cte for i in res {
            sock.read (cast!(p!void) (&i), i::sizeof);
        }

        for it in 0U .. msg.slots.len
            msg.slots [it] (res.expand);
    }

    def connect (T...) (ref msg : Msg!T, foo : dg (T) -> void) {
        msg.slots = msg.slots ~ [foo];
    }

    def new (T...) (ref proto : Protocol) {
        let static last = 0UL;
        last ++;
        return Msg!T {last, [], &proto};
    }
}
