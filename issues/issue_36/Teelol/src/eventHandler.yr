mod src.eventHandler;

import core.io;
import std.list;
import src.lib.sdl;
import src.lib.signal;
import src.game;

struct
| type : uint
| signal : Signal!(ref Game)
 -> ClassicEvent;

struct
| type : uint
| keyCode : int
| signal : Signal!(ref Game)
 -> KeyboardEvent;

struct
| type : uint
| buttonCode : int
| pos : t!(int, int) // posX, posY
 -> MouseEvent;

struct
| classicEvents : List!ClassicEvent
| keyboardEvents : List!KeyboardEvent
| keyboardWithKeyRepeatEvents : List!KeyboardEvent // we must use a SDL_Scancode instead of a SDL_Keycode in this case
| mouseEvents : List!MouseEvent
| sdlEvent : SDL_Event
| game : p!Game
| delayKeyRepeat : uint
 -> EventHandler;

imut gDefaultKeyRepeatDelay = 100u;

def createEventHandler (ref game : Game) -> mut EventHandler
{
    let listClassicEvent = list!ClassicEvent ();
    let listKeyboardEvent = list!KeyboardEvent ();
    let listKeyboardWithKeyRepeatEvent = list!KeyboardEvent ();
    let listMouseEvents = list!MouseEvent ();
    let sdlEvent = SDL_Event::init;
    return EventHandler { listClassicEvent, listKeyboardEvent, listKeyboardWithKeyRepeatEvent, listMouseEvents, sdlEvent, &game, gDefaultKeyRepeatDelay };
}

def onEvent (ref eventHdl : EventHandler, eventType : SDL_EventType, signal : Signal!(ref Game))
{
    eventHdl.classicEvents.push (ClassicEvent { eventType, signal });
}

def onEvent (ref eventHdl : EventHandler, eventType : SDL_EventType, keyCode : SDL_Keycode, signal : Signal!(ref Game))
{
    eventHdl.keyboardEvents.push (KeyboardEvent { eventType, keyCode, signal });
}

def onEvent (ref eventHdl : EventHandler, eventType : SDL_EventType, keyScanCode : SDL_Scancode, signal : Signal!(ref Game))
{
    eventHdl.keyboardWithKeyRepeatEvents.push (KeyboardEvent { eventType, keyScanCode, signal });
}

def onEvent (ref eventHdl : EventHandler, eventType : SDL_EventType, buttonCode : SDL_Mousecode, signal : Signal!(ref Game, t!(int, int)))
{
    eventHdl.mouseEvents.push (MouseEvent { eventType, buttonCode, signal });
}

def handleEvents(ref eventHdl : EventHandler)
{
    // We don't have to call it because SDL_PollEvent must call it itself
    // SDL_PumpEvents();

    let sdlEventPtr = &(eventHdl.sdlEvent);

    // We first handle non-keyboard events
    if (SDL_PollEvent (sdlEventPtr) != 0)
    {
        if ((*sdlEventPtr).type == SDL_EventType::Quit)
        {
            eventHdl.handleClassicEvent ((*sdlEventPtr).type);
        }
        else if ((*sdlEventPtr).type == SDL_EventType::SDL_MOUSEBUTTONDOWN)
        {
            let mouseEvent = cast!(SDL_MouseButtonEvent) (sdlEventPtr);
            eventHdl.handleMouseEvent ((*sdlEventPtr).type, (*mouseEvent).button, ((*mouseEvent).x, (*mouseEvent.y)));
        }
    }
    else
    {
        // Then we handle keyboard events with keys that need keyrepeat behaviour
        let states = SDL_GetKeyboardState(null);
        let handledKeyRepeat = eventHdl.handleKeyboardWithKeyRepeatEvent ((*sdlEventPtr).type, states);
        SDL_Delay (eventHdl.delayKeyRepeat);

        // If no one was detected, we handle classic keyboard events
        if (!handledKeyRepeat && (*sdlEventPtr).type == SDL_EventType::KeyDown || (*sdlEventPtr).type == SDL_EventType::KeyUp)
        {
            let keyCode = cast!(p!SDL_KeyboardEvent) (sdlEventPtr);
            eventHdl.handleKeyboardEvent ((*sdlEventPtr).type, (*keyCode).sym);
        }
    }
}

def handleClassicEvent (ref eventHdl : EventHandler, eventType : uint)
{
    let next_ = eventHdl.classicEvents.next ();
    while (next_ !is null)
    {
        if ((*next_).value.type == eventType)
        {
            let sig = (*next_).value.signal;
            sig.call (*(eventHdl.game));
        }
        next_ = next(next_);
    }
}

def handleKeyboardEvent (ref eventHdl : EventHandler, eventType : uint, keyCode : int)
{
    let next_ = eventHdl.keyboardEvents.next();
    while (next_ !is null)
    {
        if ((*next_).value.type == eventType && (*next_).value.keyCode == keyCode)
        {
            let sig = (*next_).value.signal;
            sig.call (*(eventHdl.game));
        }
        next_ = next_.next();
    }
}

// Returns true if an keyboard event was handled
def handleKeyboardWithKeyRepeatEvent (ref eventHdl : EventHandler, eventType : uint, const keyboardState : p!ubyte) -> bool
{
    let next_ = eventHdl.keyboardWithKeyRepeatEvents.next();
    let ret = false;
    while (next_ !is null)
    {
        if (*(keyboardState + ((*next_).value.keyCode)) == 1ub)
        {
            let sig = (*next_).value.signal;
            sig.call (*(eventHdl.game));
            ret = true;
        }
        next_ = next_.next();
    }
    return ret;
}

def handleMouseEvent (ref eventHdl : EventHandler, eventType : uint, buttonCode : int, pos : t!(int, int))
{
    let next_ = eventHdl.mouseEvents.next();
    while (next_ !is null)
    {
        if ((*next_).value.type == eventType && (*next_).value.buttonCode == keyCode)
        {
            let sig = (*next_).value.signal;
            sig.call (*(eventHdl.game), pos);
        }
        next_ = next_.next();
    }    
}
