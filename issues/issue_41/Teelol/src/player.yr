mod src.player;

import src.lib.sdl;
import src.resource;
import src.drawable;
import src.collision;

import core.io;
import std.list;

extern (C) sinf (value : float) -> float;
extern (C) cosf (value : float) -> float;
extern (C) abs (value : int) -> int;

struct
| name : string
| body : Drawable
| eyes : Drawable
| speedX : int
| speedY : int
| vX : float
| vY : float
| speedInit : int
| angleInit : float
| timer : int
| jumpsCount : int
| isJumping : bool
| g : float // tmp because immutable floats are not implemented yet !
| pi : float
| startPosX : int
| startPosY : int
| lastPosY : int
 -> Player;

private
{
    imut gHorizontalSpeed = 1;
    imut gVerticalSpeed = 1;
    imut gMaxJumpsCount = 2;
    imut gG = 9.81f;
    imut gPi = 3.14f;
}

def createPlayer (name : string, const posX : int, const posY : int, resType : ResourceType) -> Player
{
    let resManager = getResourcesManager ();
    let bodyRes = resManager.getResource (resType);
    let eyesRes = resManager.getResource (ResourceType::Eyes);
    let body = Drawable { Position { posX, posY }, bodyRes };
    let eyes = Drawable { Position { posX + 4, posY + 4 }, eyesRes };
    return Player { name, body, eyes, 0, 0, float::init, float::init, 0, float::init, 0, 0, false, 9.81f, 3.14f, 0, 0, 0 };
}

def getDrawables (ref player : Player) -> mut List!(p!Drawable)
{
    let res = list!(p!Drawable) ();
    res.push (&(player.body));
    res.push (&(player.eyes));
    return res;
}

def jump (ref player : Player)
{
    if (player.jumpsCount < gMaxJumpsCount)
    {
        player.isJumping = true;
        player.timer = 0;

        if (player.speedX > 0 || player.speedX < 0)
        {
            println ("speedX: ", player.speedX);
            player.speedInit = player.speedX;
            player.angleInit = gPi / 3;
        }
        else
        {
            player.speedInit = gVerticalSpeed;
            player.angleInit = gPi / 2;
        }

        player.vX = cosf (player.angleInit) * abs(player.speedInit);
        player.vY = sinf (player.angleInit) * abs(player.speedInit);
        player.startPosX = player.body.pos.x;
        player.startPosY = player.body.pos.y;

        player.lastPosY = player.startPosY;
        
        player.jumpsCount++;
    }
}

def fall (ref player : Player)
{
    let colManager = getCollisionManager ();
    if (colManager.canGoDown (player, gVerticalSpeed))
    {
        player.speedY = gVerticalSpeed;;
    }
    else
    {
        player.jumpsCount = 0;
        player.stopMoveY ();
    }
}

def goRight (ref player : Player)
{
    if (!player.isJumping)
    {
        let colManager = getCollisionManager ();
        if (colManager.canGoRight (player, gHorizontalSpeed))
            player.speedX = gHorizontalSpeed;
        else
            player.stopMoveX ();
    }
}

def goLeft (ref player : Player)
{
    if (!player.isJumping)
    {
        let colManager = getCollisionManager ();
        if (colManager.canGoLeft (player, gHorizontalSpeed))
            player.speedX = -gHorizontalSpeed;
        else
            player.stopMoveX ();
    }
}

def stopMoveX (ref player : Player)
{
    player.speedX = 0;
}

def stopMoveY (ref player : Player)
{
    player.speedY = 0;
}

def goTo (ref player : Player, posX : int, posY : int)
{
    player.body.pos.x = posX;
    player.body.pos.y = posY;
}

def passRow (ref player : Player)
{    
    if (player.isJumping)
    {
        let relX = cast!int (player.vX * player.timer);
        let relY = cast!int ((player.vY * player.timer) - ((gG * player.timer * player.timer) / 2000));

        if (player.speedInit < 0)
            player.body.pos.x = player.startPosX - relX;
        else
            player.body.pos.x = player.startPosX + relX;
        
        player.body.pos.y = player.startPosY - relY;

        player.timer += 3;

        let colManager = getCollisionManager ();
        if ((player.lastPosY - player.body.pos.y) < 0)
        {
            if (!colManager.canGoDown (player, 1))
            {
                player.stopMoveY ();
                player.isJumping = false;
                player.jumpsCount = 0;
            }
        }

        if (!colManager.canGoRight (player, gHorizontalSpeed) && player.speedInit > 0)
        {
            player.stopMoveX ();
            player.isJumping = false;
        }

        if (!colManager.canGoLeft (player, gHorizontalSpeed) && player.speedInit < 0)
        {
            player.stopMoveX ();
            player.isJumping = false;
        }
        
        player.lastPosY = player.body.pos.y;
    }
    
    if (!player.isJumping)
    {
        player.body.pos.x += player.speedX;
        player.body.pos.y += player.speedY;
        player.eyes.pos.x += player.speedX;
        player.eyes.pos.y += player.speedY;

        if (player.speedX > 0)
            player.speedX -= 1;
        else if (player.speedX < 0)
            player.speedX += 1;

        player.fall ();
    }
}
