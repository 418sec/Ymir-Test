core.io.src.screen.print (struct char[] a, struct char[] b)
{
  {
    core.io.print (a);
    core.io.print (b);
  }
}


src.screen.printErr (struct char[] message)
{
  {
    struct char[] _1_;

    try
      {
        _1_.len = 3;
        _1_.ptr = &" : "[0];
        core.io.src.screen.print (message, _1_);
        _1 = src.lib.sdl.SDL_GetError ();
        src.screen.printf (&"%s"[0], _1);
      }
    finally
      {
        _1_ = {CLOBBER};
      }
  }
}


std.list.src.screen.list(Psrc.lib.sdl.SDL_Rect) ()
{
  struct std.list.List!(ptr!src.lib.sdl.SDL_Rect) D.72;

  {
    struct std.list.List!(ptr!src.lib.sdl.SDL_Rect) _1_;

    try
      {
        _1_.head = 0B;
        D.72 = _1_;
        return D.72;
      }
    finally
      {
        _1_ = {CLOBBER};
      }
  }
}


src.screen.createScreen (struct char[] title, signed int windowWidth, signed int windowHeight, signed int windowPosX, signed int windowPosY)
{
  {
    struct src.screen.Screen screen;
    struct src.screen.Screen _2_;

    try
      {
        _1 = src.lib.sdl.SDL_Init (32);
        if (_1 != 0) goto <D.119>; else goto <D.120>;
        <D.119>:
        goto then;
        <D.120>:
        goto end_if;
        then:
        {
          struct char[] _1_;

          try
            {
              _1_.len = 16;
              _1_.ptr = &"SDL_Init() error"[0];
              src.screen.printErr (_1_);
              std.abort.abort ();
            }
          finally
            {
              _1_ = {CLOBBER};
            }
        }
        goto end_if;
        end_if:
        memset (&_2_, 0, 40);
        screen = _2_;
        _2 = title.ptr;
        _3 = src.lib.sdl.SDL_CreateWindow (_2, windowPosX, windowPosY, windowWidth, windowHeight, 4);
        screen.window = _3;
        _4 = screen.window;
        if (_4 == 0B) goto <D.121>; else goto <D.122>;
        <D.121>:
        goto then;
        <D.122>:
        goto end_if;
        then:
        {
          struct char[] _3_;

          try
            {
              _3_.len = 24;
              _3_.ptr = &"SDL_CreateWindow() error"[0];
              src.screen.printErr (_3_);
              std.abort.abort ();
            }
          finally
            {
              _3_ = {CLOBBER};
            }
        }
        goto end_if;
        end_if:
        _5 = -1;
        _6 = screen.window;
        _7 = src.lib.sdl.SDL_CreateRenderer (_6, _5, 2);
        screen.renderer = _7;
        _8 = screen.renderer;
        if (_8 == 0B) goto <D.123>; else goto <D.124>;
        <D.123>:
        goto then;
        <D.124>:
        goto end_if;
        then:
        {
          struct char[] _4_;

          try
            {
              _4_.len = 26;
              _4_.ptr = &"SDL_CreateRenderer() error"[0];
              src.screen.printErr (_4_);
              std.abort.abort ();
            }
          finally
            {
              _4_ = {CLOBBER};
            }
        }
        goto end_if;
        end_if:
        _9 = screen.renderer;
        src.lib.sdl.SDL_RenderSetLogicalSize (_9, windowWidth, windowHeight);
        screen.rects = std.list.src.screen.list(Psrc.lib.sdl.SDL_Rect) ();
        <retval> = screen;
        return <retval>;
      }
    finally
      {
        screen = {CLOBBER};
        _2_ = {CLOBBER};
      }
  }
}


src.screen.clear (void * screen)
{
  {
    typedef struct std.list.List!(ptr!src.lib.sdl.SDL_Rect) ;
    typedef struct src.lib.sdl.SDL_Rect ;
    typedef struct src.screen.Screen ;

    _1 = MEM[(struct src.screen.Screen *)screen].renderer;
    src.lib.sdl.SDL_SetRenderDrawColor (_1, 0, 0, 0, 255);
    _2 = MEM[(struct src.screen.Screen *)screen].renderer;
    src.lib.sdl.SDL_RenderClear (_2);
  }
}


std.list.src.screen.next (void * list)
{
  void * D.147;

  {
    typedef struct std.list.List!(ptr!src.lib.sdl.SDL_Rect) ;

    D.147 = MEM[(struct std.list.List!(ptr!src.lib.sdl.SDL_Rect) *)list].head;
    return D.147;
  }
}


src.screen.display (void * screen)
{
  {
    typedef struct std.list.List!(ptr!src.lib.sdl.SDL_Rect) ;
    typedef struct src.lib.sdl.SDL_Rect ;
    typedef struct src.screen.Screen ;
    void * next_;

    _1 = MEM[(struct src.screen.Screen *)screen].renderer;
    src.lib.sdl.SDL_SetRenderDrawColor (_1, 255, 255, 255, 255);
    _2 = &MEM[(struct src.screen.Screen *)screen].rects;
    next_ = std.list.src.screen.next (_2);
    goto test;
    begin:
    {
      typedef struct std.list.Node!(ptr!src.lib.sdl.SDL_Rect) ;

      _3 = MEM[(struct std.list.Node!(ptr!src.lib.sdl.SDL_Rect) *)next_].value;
      _4 = MEM[(struct src.screen.Screen *)screen].renderer;
      src.lib.sdl.SDL_RenderFillRect (_4, _3);
      next_ = MEM[(struct std.list.Node!(ptr!src.lib.sdl.SDL_Rect) *)next_].next;
    }
    goto test;
    test:
    if (next_ != 0B) goto <D.174>; else goto <D.175>;
    <D.174>:
    goto begin;
    <D.175>:
    goto end;
    end:
    _5 = MEM[(struct src.screen.Screen *)screen].renderer;
    src.lib.sdl.SDL_RenderPresent (_5);
  }
}


core.io.src.screen.println (struct char[] i)
{
  {
    core.io.print (i);
    core.io.print (10);
  }
}


src.screen.destroy (void * screen)
{
  {
    typedef struct char[] ;
    struct char[] _1_;
    typedef struct std.list.List!(ptr!src.lib.sdl.SDL_Rect) ;
    typedef struct src.lib.sdl.SDL_Rect ;
    typedef struct src.screen.Screen ;

    try
      {
        _1_.len = 9;
        _1_.ptr = &"destroy !"[0];
        core.io.src.screen.println (_1_);
        _1 = MEM[(struct src.screen.Screen *)screen].renderer;
        if (_1 != 0B) goto <D.210>; else goto <D.211>;
        <D.210>:
        goto then;
        <D.211>:
        goto end_if;
        then:
        {
          _2 = MEM[(struct src.screen.Screen *)screen].renderer;
          src.lib.sdl.SDL_DestroyRenderer (_2);
        }
        goto end_if;
        end_if:
        _3 = MEM[(struct src.screen.Screen *)screen].window;
        if (_3 != 0B) goto <D.212>; else goto <D.213>;
        <D.212>:
        goto then;
        <D.213>:
        goto end_if;
        then:
        {
          _4 = MEM[(struct src.screen.Screen *)screen].window;
          src.lib.sdl.SDL_DestroyWindow (_4);
        }
        goto end_if;
        end_if:
      }
    finally
      {
        _1_ = {CLOBBER};
      }
  }
}


std.memory.src.screen.alloc (struct std.list.Node!(ptr!src.lib.sdl.SDL_Rect) a)
{
  void * D.222;

  {
    void * x;

    x = C.GC_malloc (16);
    MEM[(struct std.list.Node!(ptr!src.lib.sdl.SDL_Rect) *)x] = a;
    D.222 = x;
    return D.222;
  }
}


std.list.src.screen.push (void * a, void * b)
{
  {
    typedef struct std.list.List!(ptr!src.lib.sdl.SDL_Rect) ;

    _1 = MEM[(struct std.list.List!(ptr!src.lib.sdl.SDL_Rect) *)a].head;
    if (_1 == 0B) goto <D.245>; else goto <D.246>;
    <D.245>:
    goto then;
    <D.246>:
    goto else;
    then:
    {
      typedef struct std.list.Node!(ptr!src.lib.sdl.SDL_Rect) ;
      struct std.list.Node!(ptr!src.lib.sdl.SDL_Rect) _1_;

      try
        {
          _1_.value = b;
          _1_.next = 0B;
          _2 = std.memory.src.screen.alloc (_1_);
          MEM[(struct std.list.List!(ptr!src.lib.sdl.SDL_Rect) *)a].head = _2;
        }
      finally
        {
          _1_ = {CLOBBER};
        }
    }
    goto end_if;
    else:
    {
      void * current;

      current = MEM[(struct std.list.List!(ptr!src.lib.sdl.SDL_Rect) *)a].head;
      goto test;
      begin:
      {
        _3 = MEM[(struct std.list.Node!(ptr!src.lib.sdl.SDL_Rect) *)current].next;
        if (_3 == 0B) goto <D.247>; else goto <D.248>;
        <D.247>:
        goto then;
        <D.248>:
        goto end_if;
        then:
        {
          struct std.list.Node!(ptr!src.lib.sdl.SDL_Rect) _2_;

          try
            {
              _2_.value = b;
              _2_.next = 0B;
              _4 = std.memory.src.screen.alloc (_2_);
              MEM[(struct std.list.Node!(ptr!src.lib.sdl.SDL_Rect) *)current].next = _4;
              return;
            }
          finally
            {
              _2_ = {CLOBBER};
            }
        }
        goto end_if;
        end_if:
        current = MEM[(struct std.list.Node!(ptr!src.lib.sdl.SDL_Rect) *)current].next;
      }
      goto test;
      test:
      if (current != 0B) goto <D.249>; else goto <D.250>;
      <D.249>:
      goto begin;
      <D.250>:
      goto end;
      end:
    }
    goto end_if;
    end_if:
  }
}


src.screen.addRect (void * screen, void * rect)
{
  {
    typedef struct std.list.List!(ptr!src.lib.sdl.SDL_Rect) ;
    typedef struct src.lib.sdl.SDL_Rect ;
    typedef struct src.screen.Screen ;

    _1 = &MEM[(struct src.screen.Screen *)screen].rects;
    std.list.src.screen.push (_1, rect);
  }
}


