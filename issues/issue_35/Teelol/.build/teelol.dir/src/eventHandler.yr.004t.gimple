std.list.src.eventHandler.list(x) ()
{
  struct std.list.List!(src.eventHandler.ClassicEvent) D.64;

  {
    struct std.list.List!(src.eventHandler.ClassicEvent) _1_;

    try
      {
        _1_.head = 0B;
        D.64 = _1_;
        return D.64;
      }
    finally
      {
        _1_ = {CLOBBER};
      }
  }
}


std.list.src.eventHandler.list(x) ()
{
  struct std.list.List!(src.eventHandler.KeyboardEvent) D.70;

  {
    struct std.list.List!(src.eventHandler.KeyboardEvent) _1_;

    try
      {
        _1_.head = 0B;
        D.70 = _1_;
        return D.70;
      }
    finally
      {
        _1_ = {CLOBBER};
      }
  }
}


src.eventHandler.createEventHandler (void * game)
{
  {
    struct std.list.List!(src.eventHandler.ClassicEvent) listClassicEvent;
    struct std.list.List!(src.eventHandler.KeyboardEvent) listKeyboardEvent;
    struct src.lib.sdl.SDL_Event sdlEvent;
    struct src.lib.sdl.SDL_Event _1_;
    typedef struct std.list.List!(ptr!src.lib.sdl.SDL_Rect) ;
    typedef struct src.lib.sdl.SDL_Rect ;
    typedef struct src.screen.Screen ;
    typedef struct char[] ;
    typedef struct src.player.Player ;
    typedef struct src.game.Game ;
    struct src.eventHandler.EventHandler _2_;

    try
      {
        listClassicEvent = std.list.src.eventHandler.list(x) ();
        listKeyboardEvent = std.list.src.eventHandler.list(x) ();
        memset (&_1_, 0, 56);
        sdlEvent = _1_;
        _2_.classicEvents = listClassicEvent;
        _2_.keyboardEvents = listKeyboardEvent;
        _2_.sdlEvent = sdlEvent;
        _2_.game = game;
        <retval> = _2_;
        return <retval>;
      }
    finally
      {
        listClassicEvent = {CLOBBER};
        listKeyboardEvent = {CLOBBER};
        sdlEvent = {CLOBBER};
        _1_ = {CLOBBER};
        _2_ = {CLOBBER};
      }
  }
}


std.memory.src.eventHandler.alloc (struct std.list.Node!(src.eventHandler.ClassicEvent) a)
{
  void * D.134;

  {
    void * x;

    x = C.GC_malloc (32);
    MEM[(struct std.list.Node!(src.eventHandler.ClassicEvent) *)x] = a;
    D.134 = x;
    return D.134;
  }
}


std.list.src.eventHandler.push (void * a, struct src.eventHandler.ClassicEvent b)
{
  {
    typedef struct std.list.List!(src.eventHandler.ClassicEvent) ;

    _1 = MEM[(struct std.list.List!(src.eventHandler.ClassicEvent) *)a].head;
    if (_1 == 0B) goto <D.165>; else goto <D.166>;
    <D.165>:
    goto then;
    <D.166>:
    goto else;
    then:
    {
      typedef struct std.list.Node!(src.eventHandler.ClassicEvent) ;
      struct std.list.Node!(src.eventHandler.ClassicEvent) _1_;

      try
        {
          _1_.value = b;
          _1_.next = 0B;
          _2 = std.memory.src.eventHandler.alloc (_1_);
          MEM[(struct std.list.List!(src.eventHandler.ClassicEvent) *)a].head = _2;
        }
      finally
        {
          _1_ = {CLOBBER};
        }
    }
    goto end_if;
    else:
    {
      void * current;

      current = MEM[(struct std.list.List!(src.eventHandler.ClassicEvent) *)a].head;
      goto test;
      begin:
      {
        _3 = MEM[(struct std.list.Node!(src.eventHandler.ClassicEvent) *)current].next;
        if (_3 == 0B) goto <D.167>; else goto <D.168>;
        <D.167>:
        goto then;
        <D.168>:
        goto end_if;
        then:
        {
          struct std.list.Node!(src.eventHandler.ClassicEvent) _2_;

          try
            {
              _2_.value = b;
              _2_.next = 0B;
              _4 = std.memory.src.eventHandler.alloc (_2_);
              MEM[(struct std.list.Node!(src.eventHandler.ClassicEvent) *)current].next = _4;
              return;
            }
          finally
            {
              _2_ = {CLOBBER};
            }
        }
        goto end_if;
        end_if:
        current = MEM[(struct std.list.Node!(src.eventHandler.ClassicEvent) *)current].next;
      }
      goto test;
      test:
      if (current != 0B) goto <D.169>; else goto <D.170>;
      <D.169>:
      goto begin;
      <D.170>:
      goto end;
      end:
    }
    goto end_if;
    end_if:
  }
}


src.eventHandler.onEvent (void * eventHdl, unsigned int eventType, struct src.lib.signal.Signal!(ref(src.game.Game)) signal)
{
  {
    typedef struct src.eventHandler.ClassicEvent ;
    typedef struct std.list.List!(src.eventHandler.ClassicEvent) ;
    typedef struct std.list.List!(src.eventHandler.KeyboardEvent) ;
    typedef struct src.lib.sdl.SDL_Event ;
    typedef struct src.eventHandler.EventHandler ;
    struct src.eventHandler.ClassicEvent _1_;

    try
      {
        _1_.type = eventType;
        _1_.signal = signal;
        _1 = &MEM[(struct src.eventHandler.EventHandler *)eventHdl].classicEvents;
        std.list.src.eventHandler.push (_1, _1_);
      }
    finally
      {
        _1_ = {CLOBBER};
      }
  }
}


std.memory.src.eventHandler.alloc (struct std.list.Node!(src.eventHandler.KeyboardEvent) a)
{
  void * D.215;

  {
    void * x;

    x = C.GC_malloc (32);
    MEM[(struct std.list.Node!(src.eventHandler.KeyboardEvent) *)x] = a;
    D.215 = x;
    return D.215;
  }
}


std.list.src.eventHandler.push (void * a, struct src.eventHandler.KeyboardEvent b)
{
  {
    typedef struct std.list.List!(src.eventHandler.KeyboardEvent) ;

    _1 = MEM[(struct std.list.List!(src.eventHandler.KeyboardEvent) *)a].head;
    if (_1 == 0B) goto <D.247>; else goto <D.248>;
    <D.247>:
    goto then;
    <D.248>:
    goto else;
    then:
    {
      typedef struct std.list.Node!(src.eventHandler.KeyboardEvent) ;
      struct std.list.Node!(src.eventHandler.KeyboardEvent) _1_;

      try
        {
          _1_.value = b;
          _1_.next = 0B;
          _2 = std.memory.src.eventHandler.alloc (_1_);
          MEM[(struct std.list.List!(src.eventHandler.KeyboardEvent) *)a].head = _2;
        }
      finally
        {
          _1_ = {CLOBBER};
        }
    }
    goto end_if;
    else:
    {
      void * current;

      current = MEM[(struct std.list.List!(src.eventHandler.KeyboardEvent) *)a].head;
      goto test;
      begin:
      {
        _3 = MEM[(struct std.list.Node!(src.eventHandler.KeyboardEvent) *)current].next;
        if (_3 == 0B) goto <D.249>; else goto <D.250>;
        <D.249>:
        goto then;
        <D.250>:
        goto end_if;
        then:
        {
          struct std.list.Node!(src.eventHandler.KeyboardEvent) _2_;

          try
            {
              _2_.value = b;
              _2_.next = 0B;
              _4 = std.memory.src.eventHandler.alloc (_2_);
              MEM[(struct std.list.Node!(src.eventHandler.KeyboardEvent) *)current].next = _4;
              return;
            }
          finally
            {
              _2_ = {CLOBBER};
            }
        }
        goto end_if;
        end_if:
        current = MEM[(struct std.list.Node!(src.eventHandler.KeyboardEvent) *)current].next;
      }
      goto test;
      test:
      if (current != 0B) goto <D.251>; else goto <D.252>;
      <D.251>:
      goto begin;
      <D.252>:
      goto end;
      end:
    }
    goto end_if;
    end_if:
  }
}


src.eventHandler.onEvent (void * eventHdl, unsigned int eventType, signed int keyCode, struct src.lib.signal.Signal!(ref(src.game.Game)) signal)
{
  {
    typedef struct src.eventHandler.KeyboardEvent ;
    typedef struct std.list.List!(src.eventHandler.ClassicEvent) ;
    typedef struct std.list.List!(src.eventHandler.KeyboardEvent) ;
    typedef struct src.lib.sdl.SDL_Event ;
    typedef struct src.eventHandler.EventHandler ;
    struct src.eventHandler.KeyboardEvent _1_;

    try
      {
        _1_.type = eventType;
        _1_.keyCode = keyCode;
        _1_.signal = signal;
        _1 = &MEM[(struct src.eventHandler.EventHandler *)eventHdl].keyboardEvents;
        std.list.src.eventHandler.push (_1, _1_);
      }
    finally
      {
        _1_ = {CLOBBER};
      }
  }
}


std.list.src.eventHandler.next (void * list)
{
  void * D.287;

  {
    typedef struct std.list.List!(src.eventHandler.ClassicEvent) ;

    D.287 = MEM[(struct std.list.List!(src.eventHandler.ClassicEvent) *)list].head;
    return D.287;
  }
}


src.lib.signal.src.eventHandler.call (void * sig, void * elems)
{
  {
    unsigned long it;
    typedef struct fn(ref(src.game.Game))->void[] ;
    typedef struct src.lib.signal.Signal!(ref(src.game.Game)) ;
    typedef struct R_xm ;
    struct R_xm _1_;
    unsigned long _2_;

    try
      {
        _1_.fst = 0;
        _1 = MEM[(struct src.lib.signal.Signal!(ref(src.game.Game)) *)sig].func.len;
        _1_.scd = _1;
        _2_ = _1_.fst;
        goto test;
        begin:
        {
          it = _2_;
          {
            _2 = MEM[(struct src.lib.signal.Signal!(ref(src.game.Game)) *)sig].func.ptr;
            _3 = it * 8;
            _4 = _2 + _3;
            _5 = *_4;
            _5 (elems);
          }
          _6 = _1_.fst;
          _7 = _1_.scd;
          if (_6 < _7) goto <D.307>; else goto <D.308>;
          <D.307>:
          _2_ = _2_ + 1;
          goto <D.309>;
          <D.308>:
          _2_ = _2_ + 18446744073709551615;
          <D.309>:
        }
        goto test;
        test:
        _8 = _1_.scd;
        if (_2_ != _8) goto <D.310>; else goto <D.311>;
        <D.310>:
        goto begin;
        <D.311>:
        goto end;
        end:
        end:
      }
    finally
      {
        _1_ = {CLOBBER};
      }
  }
}


std.list.src.eventHandler.next (void * nodePtr)
{
  void * D.330;

  {
    typedef struct fn(ref(src.game.Game))->void[] ;
    typedef struct src.lib.signal.Signal!(ref(src.game.Game)) ;
    typedef struct src.eventHandler.ClassicEvent ;
    typedef struct std.list.Node!(src.eventHandler.ClassicEvent) ;

    if (nodePtr == 0B) goto <D.328>; else goto <D.329>;
    <D.328>:
    goto then;
    <D.329>:
    goto end_if;
    then:
    {
      D.330 = 0B;
      return D.330;
    }
    goto end_if;
    end_if:
    D.330 = MEM[(struct std.list.Node!(src.eventHandler.ClassicEvent) *)nodePtr].next;
    return D.330;
  }
}


src.eventHandler.handleClassicEvent (void * eventHdl, unsigned int eventType)
{
  {
    void * next_;
    typedef struct std.list.List!(src.eventHandler.ClassicEvent) ;
    typedef struct std.list.List!(src.eventHandler.KeyboardEvent) ;
    typedef struct src.lib.sdl.SDL_Event ;
    typedef struct src.eventHandler.EventHandler ;

    _1 = &MEM[(struct src.eventHandler.EventHandler *)eventHdl].classicEvents;
    next_ = std.list.src.eventHandler.next (_1);
    goto test;
    begin:
    {
      typedef struct fn(ref(src.game.Game))->void[] ;
      typedef struct src.lib.signal.Signal!(ref(src.game.Game)) ;
      typedef struct src.eventHandler.ClassicEvent ;
      typedef struct std.list.Node!(src.eventHandler.ClassicEvent) ;

      _2 = MEM[(struct std.list.Node!(src.eventHandler.ClassicEvent) *)next_].value.type;
      if (eventType == _2) goto <D.391>; else goto <D.392>;
      <D.391>:
      goto then;
      <D.392>:
      goto end_if;
      then:
      {
        struct src.lib.signal.Signal!(ref(src.game.Game)) sig;
        typedef struct std.list.List!(ptr!src.lib.sdl.SDL_Rect) ;
        typedef struct src.lib.sdl.SDL_Rect ;
        typedef struct src.screen.Screen ;
        typedef struct char[] ;
        typedef struct src.player.Player ;
        typedef struct src.game.Game ;

        try
          {
            sig = MEM[(struct std.list.Node!(src.eventHandler.ClassicEvent) *)next_].value.signal;
            _3 = MEM[(struct src.eventHandler.EventHandler *)eventHdl].game;
            src.lib.signal.src.eventHandler.call (&sig, _3);
          }
        finally
          {
            sig = {CLOBBER};
          }
      }
      goto end_if;
      end_if:
      next_ = std.list.src.eventHandler.next (next_);
    }
    goto test;
    test:
    if (next_ != 0B) goto <D.393>; else goto <D.394>;
    <D.393>:
    goto begin;
    <D.394>:
    goto end;
    end:
  }
}


std.list.src.eventHandler.next (void * list)
{
  void * D.400;

  {
    typedef struct std.list.List!(src.eventHandler.KeyboardEvent) ;

    D.400 = MEM[(struct std.list.List!(src.eventHandler.KeyboardEvent) *)list].head;
    return D.400;
  }
}


std.list.src.eventHandler.next (void * nodePtr)
{
  void * D.420;

  {
    typedef struct fn(ref(src.game.Game))->void[] ;
    typedef struct src.lib.signal.Signal!(ref(src.game.Game)) ;
    typedef struct src.eventHandler.KeyboardEvent ;
    typedef struct std.list.Node!(src.eventHandler.KeyboardEvent) ;

    if (nodePtr == 0B) goto <D.418>; else goto <D.419>;
    <D.418>:
    goto then;
    <D.419>:
    goto end_if;
    then:
    {
      D.420 = 0B;
      return D.420;
    }
    goto end_if;
    end_if:
    D.420 = MEM[(struct std.list.Node!(src.eventHandler.KeyboardEvent) *)nodePtr].next;
    return D.420;
  }
}


src.eventHandler.handleKeyboardEvent (void * eventHdl, unsigned int eventType, signed int keyCode)
{
  {
    void * next_;
    typedef struct std.list.List!(src.eventHandler.ClassicEvent) ;
    typedef struct std.list.List!(src.eventHandler.KeyboardEvent) ;
    typedef struct src.lib.sdl.SDL_Event ;
    typedef struct src.eventHandler.EventHandler ;

    _1 = &MEM[(struct src.eventHandler.EventHandler *)eventHdl].keyboardEvents;
    next_ = std.list.src.eventHandler.next (_1);
    goto test;
    begin:
    {
      typedef struct fn(ref(src.game.Game))->void[] ;
      typedef struct src.lib.signal.Signal!(ref(src.game.Game)) ;
      typedef struct src.eventHandler.KeyboardEvent ;
      typedef struct std.list.Node!(src.eventHandler.KeyboardEvent) ;

      _2 = MEM[(struct std.list.Node!(src.eventHandler.KeyboardEvent) *)next_].value.type;
      if (eventType == _2) goto <D.483>; else goto end_if;
      <D.483>:
      _3 = MEM[(struct std.list.Node!(src.eventHandler.KeyboardEvent) *)next_].value.keyCode;
      if (keyCode == _3) goto then; else goto end_if;
      then:
      {
        struct src.lib.signal.Signal!(ref(src.game.Game)) sig;
        typedef struct std.list.List!(ptr!src.lib.sdl.SDL_Rect) ;
        typedef struct src.lib.sdl.SDL_Rect ;
        typedef struct src.screen.Screen ;
        typedef struct char[] ;
        typedef struct src.player.Player ;
        typedef struct src.game.Game ;

        try
          {
            sig = MEM[(struct std.list.Node!(src.eventHandler.KeyboardEvent) *)next_].value.signal;
            _4 = MEM[(struct src.eventHandler.EventHandler *)eventHdl].game;
            src.lib.signal.src.eventHandler.call (&sig, _4);
          }
        finally
          {
            sig = {CLOBBER};
          }
      }
      goto end_if;
      end_if:
      next_ = std.list.src.eventHandler.next (next_);
    }
    goto test;
    test:
    if (next_ != 0B) goto <D.484>; else goto <D.485>;
    <D.484>:
    goto begin;
    <D.485>:
    goto end;
    end:
  }
}


src.eventHandler.handleEvents (void * eventHdl)
{
  {
    void * sdlEventPtr;
    typedef struct std.list.List!(src.eventHandler.ClassicEvent) ;
    typedef struct std.list.List!(src.eventHandler.KeyboardEvent) ;
    typedef struct src.lib.sdl.SDL_Event ;
    typedef struct src.eventHandler.EventHandler ;

    sdlEventPtr = &MEM[(struct src.eventHandler.EventHandler *)eventHdl].sdlEvent;
    _1 = src.lib.sdl.SDL_PollEvent (sdlEventPtr);
    if (_1 != 0) goto <D.528>; else goto <D.529>;
    <D.528>:
    goto then;
    <D.529>:
    goto else;
    then:
    {
      _2 = MEM[(struct src.lib.sdl.SDL_Event *)sdlEventPtr].type;
      if (_2 == 256) goto <D.530>; else goto <D.531>;
      <D.530>:
      goto then;
      <D.531>:
      goto end_if;
      then:
      {
        _3 = MEM[(struct src.lib.sdl.SDL_Event *)sdlEventPtr].type;
        src.eventHandler.handleClassicEvent (eventHdl, _3);
      }
      goto end_if;
      end_if:
    }
    goto end_if;
    else:
    {
      unsigned char * states;

      states = src.lib.sdl.SDL_GetKeyboardState (0B);
      _4 = states + 79;
      _5 = *_4;
      if (_5 == 1) goto <D.532>; else goto <D.533>;
      <D.532>:
      goto then;
      <D.533>:
      goto end_if;
      then:
      {
        _6 = src.lib.sdl.SdlScanCodeToKeyCode (79);
        src.eventHandler.handleKeyboardEvent (eventHdl, 768, _6);
      }
      goto end_if;
      end_if:
      _7 = states + 80;
      _8 = *_7;
      if (_8 == 1) goto <D.534>; else goto <D.535>;
      <D.534>:
      goto then;
      <D.535>:
      goto end_if;
      then:
      {
        _9 = src.lib.sdl.SdlScanCodeToKeyCode (80);
        src.eventHandler.handleKeyboardEvent (eventHdl, 768, _9);
      }
      goto end_if;
      end_if:
      _10 = states + 81;
      _11 = *_10;
      if (_11 == 1) goto <D.536>; else goto <D.537>;
      <D.536>:
      goto then;
      <D.537>:
      goto end_if;
      then:
      {
        _12 = src.lib.sdl.SdlScanCodeToKeyCode (81);
        src.eventHandler.handleKeyboardEvent (eventHdl, 768, _12);
      }
      goto end_if;
      end_if:
      _13 = states + 82;
      _14 = *_13;
      if (_14 == 1) goto <D.538>; else goto <D.539>;
      <D.538>:
      goto then;
      <D.539>:
      goto end_if;
      then:
      {
        _15 = src.lib.sdl.SdlScanCodeToKeyCode (82);
        src.eventHandler.handleKeyboardEvent (eventHdl, 768, _15);
      }
      goto end_if;
      end_if:
      src.lib.sdl.SDL_Delay (100);
    }
    goto end_if;
    end_if:
  }
}


