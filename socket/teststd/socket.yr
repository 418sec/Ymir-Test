mod socket;

import std.traits;
import core.io;

private mod native {
    public {
        extern (C) socket (addrFamily : int, socketType : int, protocol : int) -> int;
        extern (C) close (fd : int) -> int;
        extern (C) htons (host : ushort) -> ushort;
        extern (C) connect (socket : int, destAddr : p!SockAddr, len : uint) -> int;
        extern (C) inet_addr (const c : p!char) -> uint;
        extern (C) send (sock : int, buf : const p!void, len : const uint, flags : const int) -> int;
        extern (C) sendto (sock : int, buf : const p!void, len : const uint, flags : const int, const destAddr : p!SockAddr, addrlen : uint) -> int;
        extern (C) recv (sock : int, buf : const p!void, len : const uint, flags : const int) -> int;
        extern (C) recvfrom (sock : int, buf : const p!void, len : const uint, flags : const int, sourceAddr : p!SockAddr, addrlen : uint) -> int;
        extern (C) listen (sick : int, backlog : int) -> int;
        extern (C) bind (sock : int, my_addr : p!SockAddr, addrlen : uint) -> int;
        extern (C) accept (sock : int, addr : p!SockAddr, addrlen : p!uint) -> int;
        extern (C) inet_aton (const cp : p!char, inp : p!InAddr) -> int;
    }
}

struct
| handle : int
| addrFamily : AddrFamily
| sockType : SocketType
 -> Socket;

struct
| s_addr : uint
 -> InAddr;

struct
| sin_family : short
| sin_port : ushort
| sin_addr : InAddr
| sin_zero : [char ; 8u]
 -> SockAddrIn;

struct
| sa_family : ushort
| sa_data : [char ; 14u]
 -> SockAddr;

/* Source : socket.h */
enum : int
| Unspec    : 0
| Unix      : 1  /* Unix domain sockets  */
| AfInet    : 2	 /* Internet IP Protocol */
| Bridge    : 7  /* Multiprotocol bridge */
| Inet6     : 10 /* IP version 6	 */
| Max       : 12
 -> AddrFamily;

/* TODO : complete this enum by using socket.h */
enum : int
| SockStream    : 1  /* stream (connection) socket) */
| SockDGram     : 2  /* datagram (conn.less) socket */
| SockRaw       : 3  /* raw socket		    */
| SockRdm       : 4  /* reliably-delivered message  */
| SockSeqPacket : 5  /* sequential packet socket    */
| SockPacket    : 10 /* see socket.h                */
 -> SocketType;

enum : uint
| InAddrAny : 0U /* linux/in.h */
// | InAddrBroadcast : 0xffffffffU
 -> AddrType;

/* TODO : complete the enum by using in.h */
enum : int
| Ip   : 0
| Icmp : 1
| Igmp : 2
| Ipip : 4
| Tcp  : 6
| Egp  : 8
| Pup  : 12
| Udp  : 17
| Ipv6 : 41
| Raw  : 255
 -> IpProtocol;

def CreateSocket (addrFamily : AddrFamily, sockType : SocketType) -> Socket {
    return CreateSocket (addrFamily, sockType, 0);
}

def CreateSocket (addrFamily : AddrFamily, sockType : SocketType, protocol : int) -> Socket {
    let handle = native::socket (addrFamily, sockType, protocol);
    return Socket { handle, addrFamily, sockType };
}

def TcpSocket () -> Socket {
    return CreateSocket (AddrFamily::AfInet, SocketType::SockStream, IpProtocol::Tcp);
}

def UdpSocket () -> Socket {
    return CreateSocket (AddrFamily::AfInet, SocketType::SockDGram, IpProtocol::Udp);
}

// TODO : support ip addr AND hostname
def SockAddrInCreate (ref sockAddrIn : SockAddrIn, const addrFamily : AddrFamily, const port : ushort, const addr : string) -> bool {
    sockAddrIn.sin_family = cast!short(addrFamily);
    sockAddrIn.sin_port = port;

    // we try to translate the ip address into in_addr
    if (native::inet_aton (addr.ptr, &sockAddrIn.sin_addr) == 0)
        return false;
    
    return true;
}

def connect (ref socket : Socket, const ip : string, const port : ushort) -> bool {
    let remoteAddr = SockAddrIn::init;
    remoteAddr.sin_addr.s_addr = native::inet_addr (ip.ptr);
    remoteAddr.sin_family = cast!short (socket.addrFamily);
    remoteAddr.sin_port = native::htons (port);

    return native::connect (socket.handle, cast!(p!SockAddr) (&remoteAddr), SockAddrIn::sizeof) == 0;
}

def bind (ref socket : Socket, port : ushort) -> bool {
    let localAddr = SockAddrIn::init;
    localAddr.sin_family = cast!short (socket.addrFamily);
    localAddr.sin_port = native::htons (port);
    return native::bind (socket.handle, cast!(p!SockAddr) (&localAddr), SockAddrIn::sizeof) == 0;
}

def listen (ref socket : Socket, backlog : int) -> bool {
    return  native::listen (socket.handle, backlog) == 0;
}

def accept (ref socket : Socket, ref clientSocket : Socket, ref clientAddr : SockAddrIn) -> bool {
    let lenAddr = SockAddrIn::sizeof;
    let ret = native::accept (socket.handle, cast!(p!SockAddr) (&clientAddr), cast!(p!uint) (&lenAddr));
    if (ret < 0)
        return false;
    clientSocket.handle = ret;
    return true;
}

def close (ref socket : Socket) {
    native::close (socket.handle);
}

def send (ref socket : Socket, const message : p!byte, const size : uint, const flag : int) -> bool {
    return native::send (socket.handle, cast!(p!void) (message), size, flag) >= 0;
}

def send (T of [U], U) (ref socket : Socket, const message : T, const flag : int) -> bool {
    return socket.send (cast!(p!byte) (message.ptr), cast!uint(message.len), flag);
}

def send (T of [U], U) (ref socket : Socket, const message : T) -> bool {
    return socket.send (cast!(p!byte) (message.ptr), cast!uint(message.len), 0);
}

def send (T) (ref socket : Socket, message : T, const flag : int) -> bool {
    return socket.send (cast!(p!byte) (&message), T::sizeof, flag);
}

def send (T) (ref socket : Socket, message : T) -> bool {
    return socket.send (cast!(p!byte) (&message), T::sizeof, 0);
}

def recv (T of [U], U) (ref socket : Socket, ref outBuffer : T, flag : int) -> int {
    return native::recv (socket.handle, cast!(p!void) (outBuffer.ptr), cast!(uint)(outBuffer.len), flag);
}

def recv (T of [U], U) (ref socket : Socket, ref outBuffer : T) -> int {
    return socket.recv (outBuffer, 0);
}

def recv (T) (ref socket : Socket, ref outBuffer : T, const flag : int) -> int {
    return native::recv (socket.handle, cast!(p!void) (&outBuffer), T::sizeof, flag);
}

def recv (T) (ref socket : Socket, ref outBuffer : T) -> int {
    return socket.recv (outBuffer, 0);
}

def sendTo (ref socket : Socket, const message : p!byte, const size : uint, const destAddr : p!SockAddr, addrlen : uint, const flag : int) -> bool {
    let s = native::sendto (socket.handle, cast!(p!void) (message), size, flag, destAddr, addrlen);
    return s >= 0;
}

def sendTo (T of [U], U) (ref socket : Socket, const message : T, const destAddr : p!SockAddr, addrlen : uint, const flag : int) -> bool {
    return socket.sendTo (cast!(p!byte) (message.ptr), cast!uint(message.len), destAddr, addrlen, flag);
}

def sendTo (T of [U], U) (ref socket : Socket, const message : T, const destAddr : p!SockAddr, addrlen : uint) -> bool {
    return socket.sendTo (cast!(p!byte) (message.ptr), cast!uint(message.len), destAddr, addrlen, 0);
}

def sendTo (T) (ref socket : Socket, message : T, const flag : int, const destAddr : p!SockAddr, addrlen : uint) -> bool {
    return socket.sendTo (cast!(p!byte) (&message), T::sizeof, destAddr, addrlen, flag);
}

def sendTo (T) (ref socket : Socket, message : T, const destAddr : p!SockAddr, addrlen : uint) -> bool {
    return socket.sendTo (cast!(p!byte) (&message), T::sizeof, destAddr, addrlen, 0);
}

def recvFrom (T of [U], U) (ref socket : Socket, ref outBuffer : T, srcAddr : p!SockAddr, addrlen : uint, flag : int) -> int {
    // println ("recv using ", socket, " on ", *srcAddr, " of size : ", addrlen);
    println ("recv...");
    return native::recvfrom (socket.handle, cast!(p!void) (outBuffer.ptr), cast!(uint)(outBuffer.len), flag, srcAddr, addrlen);
}

def recvFrom (T of [U], U) (ref socket : Socket, ref outBuffer : T, srcAddr : p!SockAddr, addrlen : uint) -> int {
    return socket.recvFrom (outBuffer, srcAddr, addrlen, 0);
}

def recvFrom (T) (ref socket : Socket, ref outBuffer : T, srcAddr : p!SockAddr, addrlen : uint,  const flag : int) -> int {
    return native::recvFrom (socket.handle, cast!(p!void) (&outBuffer), T::sizeof, srcAddr, addrlen, flag);
}

def recvFrom (T) (ref socket : Socket, ref outBuffer : T, srcAddr : p!SockAddr, addrlen : uint) -> int {
    return socket.recvFrom (outBuffer, srcAddr, addrlen, 0);
}
