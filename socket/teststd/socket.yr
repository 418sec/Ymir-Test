mod socket;

import std.traits;

private mod native {
    public {
        extern (C) socket (addrFamily : int, socketType : int, protocol : int) -> int;
        extern (C) close (fd : int) -> int;
        extern (C) htons (host : ushort) -> ushort;
        extern (C) connect (socket : int, serverAddr : p!SockAddr, len : uint) -> int;
        extern (C) inet_addr (const c : p!char) -> uint;
        extern (C) send (sock : int, buf : const p!void, len : const uint, flags : const int) -> int;
        extern (C) recv (sock : int, buf : const p!void, len : const uint, flags : const int) -> int;
        extern (C) listen (sick : int, backlog : int) -> int;
        extern (C) bind (sock : int, my_addr : p!SockAddr, addrlen : uint) -> int;
        extern (C) accept (sock : int, addr : p!SockAddr, addrlen : p!uint) -> int;
    }
}

struct
| handle : int
| addrFamily : AddrFamily
| sockType : SocketType
 -> Socket;

struct
| s_addr : uint
 -> InAddr;

struct
| sin_family : short
| sin_port : ushort
| sin_addr : InAddr
| sin_zero : [char ; 8u]
 -> SockAddrIn;

struct
| sa_family : ushort
| sa_data : [char ; 14u]
 -> SockAddr;

/* Source : socket.h */
enum : int
| Unspec    : 0
| Unix      : 1  /* Unix domain sockets  */
| AfInet    : 2	 /* Internet IP Protocol */
| Bridge    : 7  /* Multiprotocol bridge */
| Inet6     : 10 /* IP version 6	 */
| Max       : 12
 -> AddrFamily;

/* TODO : complete this enum by using socket.h */
enum : int
| SockStream    : 1  /* stream (connection) socket) */
| SockDGram     : 2  /* datagram (conn.less) socket */
| SockRaw       : 3  /* raw socket		    */
| SockRdm       : 4  /* reliably-delivered message  */
| SockSeqPacket : 5  /* sequential packet socket    */
| SockPacket    : 10 /* see socket.h                */
 -> SocketType;

enum : uint
| InAddrAny : 0U /* linux/in.h */
 -> AddrType;

def CreateSocket (addrFamily : AddrFamily, sockType : SocketType) -> Socket {
    return CreateSocket (addrFamily, sockType, 0);
}

def CreateSocket (addrFamily : AddrFamily, sockType : SocketType, protocol : int) {
    let handle = native::socket (addrFamily, sockType, protocol);
    return Socket { handle, addrFamily, sockType };
}

def connect (ref socket : Socket, const ip : string, const port : ushort) -> bool {
    let remoteAddr = SockAddrIn::init;
    remoteAddr.sin_addr.s_addr = native::inet_addr (ip.ptr);
    remoteAddr.sin_family = cast!short (socket.addrFamily);
    remoteAddr.sin_port = native::htons (port);

    return native::connect (socket.handle, cast!(p!SockAddr) (&remoteAddr), SockAddrIn::sizeof) == 0;
}

def bind (ref socket : Socket, port : ushort) -> bool {
    let localAddr = SockAddrIn::init;
    localAddr.sin_family = cast!short (socket.addrFamily);
    localAddr.sin_port = native::htons (port);
    return native::bind (socket.handle, cast!(p!SockAddr) (&localAddr), SockAddrIn::sizeof) == 0;
}

def listen (ref socket : Socket, backlog : int) -> bool {
    return  native::listen (socket.handle, backlog) == 0;
}

def accept (ref socket : Socket, ref clientSocket : Socket, ref clientAddr : SockAddrIn) -> bool {
    let lenAddr = SockAddrIn::sizeof;
    let ret = native::accept (socket.handle, cast!(p!SockAddr) (&clientAddr), cast!(p!uint) (&lenAddr));
    if (ret < 0)
        return false;
    clientSocket.handle = ret;
    return true;
}

def close (ref socket : Socket) {
    native::close (socket.handle);
}

def send (ref socket : Socket, const message : p!byte, const size : uint, const flag : int) -> bool {
    return native::send (socket.handle, cast!(p!void) (message), size, flag) >= 0;
}

def send (T of [U], U) (ref socket : Socket, const message : T, const flag : int) -> bool {
    return socket.send (cast!(p!byte) (message.ptr), cast!uint(message.len), flag);
}

def send (T of [U], U) (ref socket : Socket, const message : T) -> bool {
    return socket.send (cast!(p!byte) (message.ptr), cast!uint(message.len), 0);
}

def send (T) (ref socket : Socket, message : T, const flag : int) -> bool {
    return socket.send (cast!(p!byte) (&message), T::sizeof, flag);
}

def send (T) (ref socket : Socket, message : T) -> bool {
    return socket.send (cast!(p!byte) (&message), T::sizeof, 0);
}

def recv (T of [U], U) (ref socket : Socket, ref outBuffer : T, flag : int) -> int {
    return native::recv (socket.handle, cast!(p!void) (outBuffer.ptr), cast!(uint)(outBuffer.len), flag);
}

def recv (T of [U], U) (ref socket : Socket, ref outBuffer : T) -> int {
    return socket.recv (outBuffer, 0);
}

def recv (T) (ref socket : Socket, ref outBuffer : T, const flag : int) -> int {
    return native::recv (socket.handle, cast!(p!void) (&outBuffer), T::sizeof, flag);
}

def recv (T) (ref socket : Socket, ref outBuffer : T) -> int {
    return socket.recv (outBuffer, 0);
}
