import core.io;

extern (C) system (c : p!(const char));
extern (C) scanf (c : p!(const char), ...);
extern (C) rand () -> u32;
extern (C) time (i : u64) -> u64;
extern (C) srand (i : u64);


enum
| UP : 0
| DOWN : 1
| LEFT : 2
| RIGHT : 3
 -> movDir;

struct
| val : u32
| blocked : bool
 -> Tile;

struct
| brd : [[Tile ; 4U] ; 4U]
| win : bool
| done : bool
| moved : bool
| score : u32
 -> Grid;

def grid () -> mut Grid {
    let g = Grid::init;
    g.moved = true;
    return g;
}

def loop (ref g : Grid) {
    g.addTile  ();
    while true {
        if g.moved { g.addTile (); }
        g.draw ();
        if g.done { break; }
        g.wait ();
    }
    
    match g.win {
        true => println ("You've made it !!");
        _ => println ("Game Over.");
    }
}

def draw (ref g : Grid) {
    system ("clear".ptr);
    println ("Score : ", g.score);

    for y in 0 .. 4 {
        print ("+------+------+------+------+\n| ");
        for x in 0 .. 4 {
            if g.brd [x][y].val == 0 { print ("    "); }
            else if (g.brd [x][y].val >= 1000)
                print (g.brd [x][y].val);
            else if (g.brd [x][y].val >= 100)
                print (" ", g.brd [x][y].val);
            else if (g.brd [x][y].val >= 10)
                print (" ", g.brd [x][y].val, " ");
            else
                print ("  ", g.brd [x][y].val, " ");
            print (" | ");
        }
        println ("");
    }
    println ("+------+------+------+------+");
}
    
def wait (ref g : Grid) {
    g.moved = false; let c = char::init;
    print ("(W)Up (S)Down (A)Left (D)Right ");
    scanf ("%c".ptr, &c);
    match c {
        'W' => g.move (movDir::UP);
        'A' => g.move (movDir::LEFT);
        'S' => g.move (movDir::DOWN);
        'D' => g.move (movDir::RIGHT);        
    }

    for y in 0 .. 4 {
        for x in 0 .. 4 {
            g.brd [x][y].blocked = false;
        }
    }
}

def addTile (ref g : Grid) {
    for y in 0 .. 4 {
        for x in 0 .. 4 {
            if g.brd [x][y].val == 0 {
                let a = rand () % 4U, b = rand () % 4U;
                while g.brd [a][b].val != 0 {
                    a = rand () % 4U;
                    b = rand () % 4U;
                }
                
                let s = rand () % 100U;
                if s > 89U { g.brd [a][b].val = 4U; }
                else g.brd [a][b].val = 2U;
                if g.canMove () { return; }
            }
        }
    }
    g.done = true;
}

def canMove (ref g : Grid) {
    for y in 0 .. 4  {
        for x in 0 .. 4 {
            if g.brd [x][y].val == 0 { return true; }
        }        
    }

    for y in 0 .. 4 {
        for x in 0 .. 4 {
            if g.testAdd (x + 1, y, g.brd [x][y].val) { return true; }
            if g.testAdd (x - 1, y, g.brd [x][y].val) { return true; }
            if g.testAdd (x, y + 1, g.brd [x][y].val) { return true; }
            if g.testAdd (x, y - 1, g.brd [x][y].val) { return true; }
        }
    }
    return false;
}

def testAdd (ref g : Grid, x : i32, y : i32, v : u32) {
    if (x < 0 || x > 3 || y < 0 || y > 3) return false;
    return g.brd [x][y].val == v;
}

def moveVert (ref g : Grid, x : i32, y : i32, d : i32) {
    if (g.brd[x][y + d].val != 0 &&
        g.brd [x][y + d].val == g.brd [x][y].val &&
        !g.brd [x][y].blocked &&
        !g.brd [x][y + d].blocked) {
        g.brd [x][y].val = 0U;
        g.brd [x][y + d].val *= 2U;
        g.score += g.brd [x][y + d].val;
        g.brd [x][y + d].blocked = true;
        g.moved = true;
    } else if (g.brd [x][y + d].val == 0 && g.brd [x][y].val != 0) {
        g.brd [x][y + d].val = g.brd [x][y].val;
        g.brd [x][y].val = 0U;
        g.moved = true;
    }

    if (d > 0) { if (y + d < 3) g.moveVert (x, y + d, 1); }
    else { if (y + d > 0) g.moveVert (x, y + d, -1); }
}

def moveHori (ref g : Grid, x : i32, y : i32, d : i32) {
    if (g.brd [x + d][y].val != 0 &&
        g.brd [x + d][y].val == g.brd [x][y].val &&
        !g.brd [x][y].blocked &&
        !g.brd [x + d][y].blocked) {
        g.brd [x][y].val = 0U;
        g.brd [x + d][y].val *= 2U;
        g.score += g.brd [x + d][y].val;
        g.brd [x + d][y].blocked = true;
        g.moved = true;
    } else if (g.brd[x + d][y].val == 0 && g.brd [x][y].val != 0) {
        g.brd [x + d][y].val = g.brd [x][y].val;
        g.brd [x][y].val = 0U;
        g.moved = true;
    }
    if (d > 0) { if (x + d < 3) g.moveHori (x + d, y, 1); }
    else { if (x + d > 0) g.moveHori (x + d, y, -1); }
}

def move (ref g : Grid, d : movDir) {
    match d {
        movDir::UP => {
            for x in 0 .. 4 {
                let y = 1;
                while y < 4 {
                    if (g.brd [x][y].val != 0) g.moveVert (x, y, -1);
                    y++;
                }
            }
        }
        movDir::DOWN => {
            for x in 0 .. 4 {
                let y = 2;
                while y >= 0 {
                    if (g.brd [x][y].val != 0) g.moveVert (x, y, 1);
                    y --;
                }
            }
        }
        movDir::LEFT => {
            for y in 0 .. 4 {
                let x = 1;
                while x < 4 {
                    if (g.brd [x][y].val != 0) g.moveHori (x, y, -1);
                    x++;
                }
            }
        }
        movDir::RIGHT => {
            for y in 0 .. 4 {
                let x = 2;
                while x >= 0 {
                    if (g.brd [x][y].val != 0) g.moveHori (x, y, 1);
                    x --;
                }
            }
        }
    }
}

def main () {
    srand (time (0UL));
    let g = grid ();
    g.loop ();
}
