import std::io;
import std::random;

enum
| alive = true
| dead = false
 -> Cell;

extern (C) def usleep (x : u32)-> void;
extern (C) def system (x : &(c8))-> void;

def show (array : [Cell], w : u64) {   
    for x in 0u64 .. (array.len / w) {
        print ("[");
        for y in 0_u64 .. w {
            print (if array [x * w + y] == Cell::alive 
                   "XX"
                   else "  "
            );
        }
        println ("]");
    }
    println ("");
    
}

def evolve (array : [Cell], w_ : u64) -> mut [mut Cell] {
    let mut next : [mut Cell] = alias [Cell::dead ; new array.len];
    let w = cast!i64 (w_);
    let h = cast!i64 (array.len / w_);
    for x in 0_i64 .. h {
        for y in 0_i64 .. cast!i64 (w) {
            let mut n = 0;            
            for y1 in y - 1_i64 .. y + 2_i64 {
                for x1 in x - 1_i64 .. x + 2_i64 {
                    let x_ = (x1 + h) % h;
                    let y_ = (y1 + w) % w;
                                        
                    if array [x_ * w + y_]
                        n += 1;
                }
            }
            
            if array [x * w + y] == Cell::alive { n -= 1 }
            next [x * w + y] = (n == 3 || (n == 2 && array [x * w + y] == Cell::alive));            
        }
    }
    return alias next;
}

def game (h : u64, w : u64) {
    let mut univ : [mut Cell] = alias [Cell::dead ; new h * w];
    for x_ in 0_u64 .. univ.len {
        univ [x_] = (uniform (0, 2) == 0);        
    }

    let mut i = 0;
    while true {
        println ("Generation : ", i);
        univ.show (w);
        univ = alias univ.evolve (w);
        usleep (100_000_u32);
        system ("clear"s8.ptr);
        i += 1;
    }
}

def main () {
    print ("Width : ");
    let width = read!u64 ();
    print ("Height : ");
    let height = read!u64 ();
    game (height, width);
}
